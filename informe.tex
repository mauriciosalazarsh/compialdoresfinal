\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{float}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}

\geometry{margin=2.5cm}

% Configuracion de listings para codigo
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    tabsize=4
}

\lstdefinestyle{cpp}{
    language=C++,
    morekeywords={nullptr, override, final, noexcept, constexpr, auto}
}

\lstdefinestyle{asm}{
    language=[x86masm]Assembler,
    morekeywords={push, pop, mov, add, sub, imul, idiv, cmp, jmp, jz, jnz, jl, jle, jg, jge, call, ret, lea, xor, test, sete, setne, setl, setle, setg, setge, movzx, cqo, cdqe, rbp, rsp, rax, rbx, rcx, rdx, rdi, rsi, xmm0, xmm1}
}

\lstdefinestyle{c}{
    language=C,
    morekeywords={int, long, float, unsigned, void, return, if, else, while, for, typedef}
}

% Encabezado y pie de pagina
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{CS3402 - Compiladores}
\fancyhead[R]{UTEC}
\fancyfoot[C]{\thepage}

\title{
    \vspace{-2cm}
    \Large\textbf{Universidad de Ingenieria y Tecnologia}\\[0.5cm]
    \large Facultad de Computacion\\[1cm]
    \Huge\textbf{Compilador de C a x86-64}\\[0.5cm]
    \Large Proyecto Final\\[1cm]
    \large CS3402 - Compiladores
}

\author{
    % Agregar nombres de integrantes aqui
    Integrante 1\\
    Integrante 2\\
    Integrante 3
}

\date{Noviembre 2025}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

%==============================================================================
\section{Introduccion}
%==============================================================================

El presente documento describe el diseno e implementacion de un compilador que traduce un subconjunto del lenguaje C a codigo ensamblador x86-64. El compilador fue desarrollado en C++ siguiendo una arquitectura modular que comprende las fases clasicas de compilacion: analisis lexico, analisis sintactico, analisis semantico y generacion de codigo.

\subsection{Objetivos}

\begin{itemize}
    \item Implementar un compilador funcional para un subconjunto de C
    \item Generar codigo ensamblador x86-64 ejecutable
    \item Aplicar tecnicas de optimizacion en tiempo de compilacion
    \item Soportar tipos de datos numericos adicionales (float, long, unsigned int)
    \item Implementar extensiones del lenguaje (expresiones ternarias, typedef)
\end{itemize}

\subsection{Alcance}

El compilador soporta las siguientes caracteristicas del lenguaje C:

\begin{itemize}
    \item Declaracion de variables con tipos int, long, unsigned int y float
    \item Operaciones aritmeticas, relacionales y logicas
    \item Estructuras de control: if-else, while, for
    \item Definicion y llamada de funciones, incluyendo recursion
    \item Expresiones ternarias (operador ?:)
    \item Alias de tipos mediante typedef
\end{itemize}

%==============================================================================
\section{Arquitectura del Compilador}
%==============================================================================

El compilador sigue una arquitectura de pipeline con cuatro fases principales, cada una implementada como un modulo independiente.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    block/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1cm},
    arrow/.style={->, thick}
]
    \node[block] (source) {Codigo Fuente\\(.c)};
    \node[block, right=of source] (scanner) {Scanner\\(Lexico)};
    \node[block, right=of scanner] (parser) {Parser\\(Sintactico)};
    \node[block, below=of parser] (semantic) {Semantic\\(Semantico)};
    \node[block, left=of semantic] (codegen) {CodeGen\\(Generacion)};
    \node[block, left=of codegen] (output) {Codigo x86-64\\(.s)};

    \draw[arrow] (source) -- (scanner) node[midway, above] {texto};
    \draw[arrow] (scanner) -- (parser) node[midway, above] {tokens};
    \draw[arrow] (parser) -- (semantic) node[midway, right] {AST};
    \draw[arrow] (semantic) -- (codegen) node[midway, above] {AST+tipos};
    \draw[arrow] (codegen) -- (output) node[midway, above] {asm};
\end{tikzpicture}
\caption{Pipeline del compilador}
\end{figure}

\subsection{Estructura de Archivos}

\begin{lstlisting}[style=cpp, caption=Estructura del proyecto]
Final/
|-- src/
|   |-- main.cpp          # Punto de entrada
|   |-- scanner.cpp       # Analizador lexico
|   |-- parser.cpp        # Analizador sintactico
|   |-- semantic.cpp      # Analizador semantico
|   |-- codegen.cpp       # Generador de codigo
|   |-- ast.cpp           # Nodos del AST
|   |-- symboltable.cpp   # Tabla de simbolos
|-- include/
|   |-- scanner.h
|   |-- parser.h
|   |-- ast.h
|   |-- visitor.h
|   |-- semantic.h
|   |-- codegen.h
|   |-- symboltable.h
|-- tests/                # 18 casos de prueba
|-- visualizer/           # Bonus: visualizador web
\end{lstlisting}

%==============================================================================
\section{Analisis Lexico (Scanner)}
%==============================================================================

El analizador lexico convierte el codigo fuente en una secuencia de tokens. Esta implementado en la clase \texttt{Scanner} utilizando un enfoque de analisis caracter por caracter.

\subsection{Clase Scanner}

\begin{lstlisting}[style=cpp, caption=Estructura principal del Scanner]
class Scanner {
private:
    std::string input;
    size_t pos;
    int line, column;
    char current;

    void advance();
    char peek(int offset = 1);
    void skipWhitespace();
    void skipComment();
    void skipPreprocessor();
    Token scanNumber();
    Token scanIdentifier();
    Token scanString();

public:
    Scanner(const std::string& src);
    Token nextToken();
    std::vector<Token> tokenize();
};
\end{lstlisting}

\subsection{Tipos de Tokens}

El scanner reconoce los siguientes tipos de tokens:

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Categoria} & \textbf{Tokens} & \textbf{Ejemplos} \\
\midrule
Palabras clave & int, long, float, unsigned, void & \texttt{int x;} \\
               & if, else, while, for, return & \texttt{if (x > 0)} \\
               & typedef & \texttt{typedef int entero;} \\
Literales & NUM, FLOAT\_LIT, STRING\_LIT & \texttt{42}, \texttt{3.14}, \texttt{"hola"} \\
Identificadores & ID & \texttt{variable}, \texttt{funcion} \\
Operadores & +, -, *, /, \%, ==, !=, <, >, <=, >= & \texttt{a + b} \\
           & \&\&, ||, !, ?: & \texttt{a \&\& b} \\
Delimitadores & (, ), \{, \}, [, ], ;, , & \texttt{func(a, b)} \\
\bottomrule
\end{tabular}
\caption{Tipos de tokens reconocidos}
\end{table}

\subsection{Manejo de Numeros}

El scanner detecta automaticamente el tipo de literal numerico:

\begin{lstlisting}[style=cpp, caption=Escaneo de literales numericos]
Token Scanner::scanNumber() {
    std::string num;
    bool isFloat = false;

    while (std::isdigit(current)) {
        num += current;
        advance();
    }

    // Detectar punto decimal
    if (current == '.' && std::isdigit(peek())) {
        isFloat = true;
        num += current;
        advance();
        while (std::isdigit(current)) {
            num += current;
            advance();
        }
    }

    // Detectar sufijos de tipo (u, U, L, l, f, F)
    if (current == 'u' || current == 'U') {
        isUnsigned = true;
        advance();
    }
    // ...

    return Token(isFloat ? TokenType::FLOAT_LIT
                        : TokenType::NUM, num);
}
\end{lstlisting}

%==============================================================================
\section{Analisis Sintactico (Parser)}
%==============================================================================

El analizador sintactico implementa un parser recursivo descendente que construye un Arbol de Sintaxis Abstracta (AST).

\subsection{Clase Parser}

\begin{lstlisting}[style=cpp, caption=Estructura del Parser]
class Parser {
private:
    std::vector<Token> tokens;
    size_t current;
    std::map<std::string, DataType> typeAliases;

    Token peek(int offset = 0);
    Token advance();
    bool match(TokenType type);
    bool check(TokenType type);
    void expect(TokenType type, const std::string& msg);

    DataType parseType();
    void parseTypedef();

    std::unique_ptr<Expr> parseExpression();
    std::unique_ptr<Expr> parseTernary();
    std::unique_ptr<Expr> parseLogicalOr();
    // ... mas niveles de precedencia

public:
    std::unique_ptr<Program> parse();
};
\end{lstlisting}

\subsection{Jerarquia del AST}

El AST utiliza el patron Visitor para permitir multiples recorridos:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.8cm,
    class/.style={rectangle, draw, fill=yellow!20, text width=2.5cm, text centered, minimum height=0.7cm, font=\small},
    arrow/.style={->, thick}
]
    \node[class] (node) {ASTNode};

    \node[class, below left=1cm and 1.5cm of node] (expr) {Expr};
    \node[class, below right=1cm and 1.5cm of node] (stmt) {Stmt};

    \node[class, below left=0.8cm and 0.5cm of expr] (binary) {BinaryExpr};
    \node[class, below=0.8cm of expr] (unary) {UnaryExpr};
    \node[class, below right=0.8cm and 0.5cm of expr] (ternary) {TernaryExpr};
    \node[class, below=1.8cm of binary] (literal) {LiteralExpr};
    \node[class, below=1.8cm of unary] (ident) {IdentifierExpr};
    \node[class, below=1.8cm of ternary] (call) {CallExpr};

    \node[class, below left=0.8cm and 0.3cm of stmt] (vardecl) {VarDeclStmt};
    \node[class, below=0.8cm of stmt] (ifstmt) {IfStmt};
    \node[class, below right=0.8cm and 0.3cm of stmt] (whilestmt) {WhileStmt};
    \node[class, below=1.8cm of vardecl] (assign) {AssignStmt};
    \node[class, below=1.8cm of ifstmt] (forstmt) {ForStmt};
    \node[class, below=1.8cm of whilestmt] (block) {BlockStmt};

    \draw[arrow] (expr) -- (node);
    \draw[arrow] (stmt) -- (node);
    \draw[arrow] (binary) -- (expr);
    \draw[arrow] (unary) -- (expr);
    \draw[arrow] (ternary) -- (expr);
    \draw[arrow] (literal) -- (expr);
    \draw[arrow] (ident) -- (expr);
    \draw[arrow] (call) -- (expr);
    \draw[arrow] (vardecl) -- (stmt);
    \draw[arrow] (ifstmt) -- (stmt);
    \draw[arrow] (whilestmt) -- (stmt);
    \draw[arrow] (assign) -- (stmt);
    \draw[arrow] (forstmt) -- (stmt);
    \draw[arrow] (block) -- (stmt);
\end{tikzpicture}
\caption{Jerarquia de clases del AST}
\end{figure}

\subsection{Precedencia de Operadores}

La precedencia se implementa mediante funciones de parsing separadas:

\begin{table}[H]
\centering
\begin{tabular}{clc}
\toprule
\textbf{Nivel} & \textbf{Operadores} & \textbf{Funcion} \\
\midrule
1 (menor) & ?: (ternario) & \texttt{parseTernary()} \\
2 & || & \texttt{parseLogicalOr()} \\
3 & \&\& & \texttt{parseLogicalAnd()} \\
4 & ==, != & \texttt{parseEquality()} \\
5 & <, >, <=, >= & \texttt{parseRelational()} \\
6 & +, - & \texttt{parseAdditive()} \\
7 & *, /, \% & \texttt{parseMultiplicative()} \\
8 (mayor) & -, ! (unarios) & \texttt{parseUnary()} \\
\bottomrule
\end{tabular}
\caption{Niveles de precedencia}
\end{table}

\subsection{Soporte para Typedef}

El parser mantiene un mapa de alias de tipos:

\begin{lstlisting}[style=cpp, caption=Implementacion de typedef]
void Parser::parseTypedef() {
    expect(TokenType::TYPEDEF, "Expected 'typedef'");
    DataType baseType = parseType();

    std::string aliasName = peek().lexeme;
    expect(TokenType::ID, "Expected type alias name");
    expect(TokenType::SEMICOLON, "Expected ';'");

    // Almacenar el alias
    typeAliases[aliasName] = baseType;
}

bool Parser::isTypeToken() {
    if (check(TokenType::INT) || check(TokenType::LONG) ||
        check(TokenType::FLOAT) || check(TokenType::UNSIGNED)) {
        return true;
    }
    // Verificar si es un alias de typedef
    if (check(TokenType::ID)) {
        return typeAliases.find(peek().lexeme)
               != typeAliases.end();
    }
    return false;
}
\end{lstlisting}

%==============================================================================
\section{Analisis Semantico}
%==============================================================================

El analizador semantico verifica la correccion del programa mediante el patron Visitor.

\subsection{Clase SemanticAnalyzer}

\begin{lstlisting}[style=cpp, caption=Estructura del analizador semantico]
class SemanticAnalyzer : public Visitor {
private:
    SymbolTable& symbolTable;
    DataType currentFunctionReturnType;
    bool hasErrors;
    std::string errors;

    bool areTypesCompatible(DataType expected,
                           DataType actual);
    DataType getCommonType(DataType t1, DataType t2);
    void error(const std::string& message);

public:
    void visit(BinaryExpr* node) override;
    void visit(TernaryExpr* node) override;
    void visit(CallExpr* node) override;
    void visit(VarDeclStmt* node) override;
    void visit(FunctionDecl* node) override;
    // ... otros visitors
};
\end{lstlisting}

\subsection{Sistema de Tipos}

El compilador soporta cuatro tipos numericos con promocion automatica:

\begin{lstlisting}[style=cpp, caption=Promocion de tipos]
DataType SemanticAnalyzer::getCommonType(DataType t1,
                                         DataType t2) {
    if (t1 == t2) return t1;

    // Float domina sobre todos
    if (t1 == DataType::FLOAT || t2 == DataType::FLOAT)
        return DataType::FLOAT;

    // Long domina sobre Int
    if (t1 == DataType::LONG || t2 == DataType::LONG)
        return DataType::LONG;

    // UINT con INT -> LONG (para evitar overflow)
    if ((t1 == DataType::UINT && t2 == DataType::INT) ||
        (t1 == DataType::INT && t2 == DataType::UINT))
        return DataType::LONG;

    return t1;
}
\end{lstlisting}

\subsection{Tabla de Simbolos}

La tabla de simbolos maneja ambitos anidados mediante una pila de scopes:

\begin{lstlisting}[style=cpp, caption=Estructura de la tabla de simbolos]
struct Symbol {
    std::string name;
    DataType type;
    bool isMutable;
    bool isParameter;
    int offset;  // Offset en el stack frame
    std::vector<int> arrayDimensions;
};

class SymbolTable {
private:
    std::vector<std::map<std::string, Symbol>> scopes;
    std::map<std::string, FunctionSymbol> functions;
    int currentOffset;

public:
    void enterScope();
    void exitScope();
    bool declareVariable(const std::string& name,
                        const Symbol& sym);
    Symbol* lookup(const std::string& name);
    int allocateStackSpace(int size);
};
\end{lstlisting}

%==============================================================================
\section{Generacion de Codigo}
%==============================================================================

El generador de codigo produce ensamblador x86-64 en sintaxis Intel, siguiendo la convencion de llamadas System V ABI.

\subsection{Clase CodeGenerator}

\begin{lstlisting}[style=cpp, caption=Estructura del generador de codigo]
class CodeGenerator : public Visitor {
private:
    SymbolTable& symbolTable;
    std::stringstream code;
    std::stringstream dataSection;
    int labelCounter;
    int stringCounter;
    bool enableConstantFolding;
    bool enableDeadCodeElimination;

    std::string newLabel();
    void emit(const std::string& instruction);
    void emitLabel(const std::string& label);
    void generatePrologue(const std::string& func,
                         int stackSize);
    void generateEpilogue();

public:
    void visit(BinaryExpr* node) override;
    void visit(CallExpr* node) override;
    void visit(IfStmt* node) override;
    // ... otros visitors

    std::string getCode() const;
};
\end{lstlisting}

\subsection{Convencion de Llamadas (System V ABI)}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Registro} & \textbf{Uso} \\
\midrule
rax & Valor de retorno, acumulador \\
rbx & Registro temporal (callee-saved) \\
rdi, rsi, rdx, rcx, r8, r9 & Argumentos 1-6 \\
rbp & Base pointer (marco de pila) \\
rsp & Stack pointer \\
xmm0-xmm1 & Operaciones de punto flotante \\
\bottomrule
\end{tabular}
\caption{Uso de registros x86-64}
\end{table}

\subsection{Estructura del Stack Frame}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    cell/.style={rectangle, draw, minimum width=4cm, minimum height=0.7cm, font=\small}
]
    \node[cell] at (0, 0) {Argumentos (arg3, arg2, arg1)};
    \node[cell] at (0, -0.7) {Direccion de retorno};
    \node[cell] at (0, -1.4) {RBP anterior (saved rbp)};
    \node[cell] at (0, -2.1) {Variables locales};
    \node[cell] at (0, -2.8) {Espacio temporal};

    \draw[<-] (2.5, -1.4) -- (3.5, -1.4) node[right] {rbp};
    \draw[<-] (2.5, -2.8) -- (3.5, -2.8) node[right] {rsp};

    \node at (0, 0.5) {\textbf{Direcciones altas}};
    \node at (0, -3.5) {\textbf{Direcciones bajas}};
\end{tikzpicture}
\caption{Estructura del stack frame}
\end{figure}

\subsection{Generacion de Prologo y Epilogo}

\begin{lstlisting}[style=cpp, caption=Generacion del prologo de funcion]
void CodeGenerator::generatePrologue(const std::string& func,
                                     int stackSize) {
    emitLabel(func);
    emit("push rbp");
    emit("mov rbp, rsp");

    // Alinear stack a 16 bytes (requerido por ABI)
    int alignedSize = ((stackSize + 15) & ~15);
    if (alignedSize > 0) {
        emit("sub rsp, " + std::to_string(alignedSize));
    }
}

void CodeGenerator::generateEpilogue() {
    emit("mov rsp, rbp");
    emit("pop rbp");
    emit("ret");
}
\end{lstlisting}

\subsection{Generacion de Expresiones Binarias}

\begin{lstlisting}[style=cpp, caption=Generacion de operaciones aritmeticas]
void CodeGenerator::visit(BinaryExpr* node) {
    // Evaluar operandos
    node->left->accept(this);
    emit("push rax");  // Guardar operando izquierdo

    node->right->accept(this);
    emit("mov rbx, rax");  // Operando derecho en rbx
    emit("pop rax");        // Operando izquierdo en rax

    // Generar operacion
    if (node->op == "+") {
        emit("add rax, rbx");
    } else if (node->op == "-") {
        emit("sub rax, rbx");
    } else if (node->op == "*") {
        emit("imul rax, rbx");
    } else if (node->op == "/") {
        emit("cqo");        // Sign extend rax to rdx:rax
        emit("idiv rbx");   // Resultado en rax
    } else if (node->op == "%") {
        emit("cqo");
        emit("idiv rbx");
        emit("mov rax, rdx"); // Resto en rdx
    }
    // ... operadores relacionales y logicos
}
\end{lstlisting}

\subsection{Generacion de Expresiones Ternarias}

\begin{lstlisting}[style=cpp, caption=Generacion del operador ternario]
void CodeGenerator::visit(TernaryExpr* node) {
    std::string falseLabel = newLabel();
    std::string endLabel = newLabel();

    // Evaluar condicion
    node->condition->accept(this);
    emit("test rax, rax");
    emit("jz " + falseLabel);

    // Rama verdadera
    node->trueExpr->accept(this);
    emit("jmp " + endLabel);

    // Rama falsa
    emitLabel(falseLabel);
    node->falseExpr->accept(this);

    emitLabel(endLabel);
}
\end{lstlisting}

\subsection{Generacion de Estructuras de Control}

\begin{lstlisting}[style=cpp, caption=Generacion de if-else]
void CodeGenerator::visit(IfStmt* node) {
    std::string elseLabel = newLabel();
    std::string endLabel = newLabel();

    node->condition->accept(this);
    emit("test rax, rax");

    if (node->elseBranch) {
        emit("jz " + elseLabel);
        node->thenBranch->accept(this);
        emit("jmp " + endLabel);
        emitLabel(elseLabel);
        node->elseBranch->accept(this);
        emitLabel(endLabel);
    } else {
        emit("jz " + endLabel);
        node->thenBranch->accept(this);
        emitLabel(endLabel);
    }
}
\end{lstlisting}

\begin{lstlisting}[style=cpp, caption=Generacion de bucle while]
void CodeGenerator::visit(WhileStmt* node) {
    std::string startLabel = newLabel();
    std::string endLabel = newLabel();

    emitLabel(startLabel);
    node->condition->accept(this);
    emit("test rax, rax");
    emit("jz " + endLabel);

    node->body->accept(this);
    emit("jmp " + startLabel);

    emitLabel(endLabel);
}
\end{lstlisting}

%==============================================================================
\section{Optimizaciones}
%==============================================================================

El compilador implementa dos optimizaciones principales aplicadas durante la generacion de codigo.

\subsection{Constant Folding (Plegado de Constantes)}

Esta optimizacion evalua expresiones constantes en tiempo de compilacion:

\begin{lstlisting}[style=cpp, caption=Implementacion de constant folding]
void CodeGenerator::visit(BinaryExpr* node) {
    if (enableConstantFolding) {
        auto leftLit = dynamic_cast<LiteralExpr*>(
                           node->left.get());
        auto rightLit = dynamic_cast<LiteralExpr*>(
                            node->right.get());

        if (leftLit && rightLit &&
            node->exprType != DataType::FLOAT) {
            long long leftVal = std::stoll(leftLit->value);
            long long rightVal = std::stoll(rightLit->value);
            long long result = 0;

            if (node->op == "+")
                result = leftVal + rightVal;
            else if (node->op == "-")
                result = leftVal - rightVal;
            else if (node->op == "*")
                result = leftVal * rightVal;
            else if (node->op == "/" && rightVal != 0)
                result = leftVal / rightVal;

            // Emitir resultado constante directamente
            emit("mov rax, " + std::to_string(result));
            return;
        }
    }
    // ... codigo normal si no se puede optimizar
}
\end{lstlisting}

\textbf{Ejemplo:}
\begin{lstlisting}[style=c]
int x = 5 + 10 * 2;  // Se evalua como 25 en compilacion
\end{lstlisting}

Codigo generado optimizado:
\begin{lstlisting}[style=asm]
mov rax, 25          ; En lugar de multiples operaciones
\end{lstlisting}

\subsection{Dead Code Elimination (Eliminacion de Codigo Muerto)}

El compilador detecta y omite codigo que nunca se ejecutara:

\begin{lstlisting}[style=cpp, caption=Eliminacion de codigo muerto en if]
void CodeGenerator::visit(IfStmt* node) {
    // Verificar si la condicion es constante
    if (auto lit = dynamic_cast<LiteralExpr*>(
                       node->condition.get())) {
        if (lit->value == "0") {
            // Condicion siempre falsa: solo generar else
            if (node->elseBranch) {
                node->elseBranch->accept(this);
            }
            return;  // Omitir rama then
        } else {
            // Condicion siempre verdadera: solo generar then
            node->thenBranch->accept(this);
            return;  // Omitir rama else
        }
    }
    // ... generacion normal
}
\end{lstlisting}

\textbf{Ejemplo:}
\begin{lstlisting}[style=c]
if (0) {
    z = 100;  // Este codigo nunca se ejecuta
}
\end{lstlisting}

El compilador no genera codigo para el bloque interno.

%==============================================================================
\section{Extensiones Implementadas}
%==============================================================================

\subsection{Expresiones Ternarias}

El operador ternario \texttt{?:} permite expresiones condicionales en linea:

\begin{lstlisting}[style=c, caption=Ejemplo de expresion ternaria]
int max = (x > y) ? x : y;
int result = (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
\end{lstlisting}

La implementacion en el parser:

\begin{lstlisting}[style=cpp]
std::unique_ptr<Expr> Parser::parseTernary() {
    auto expr = parseLogicalOr();

    if (match(TokenType::QUESTION)) {
        auto trueExpr = parseExpression();
        expect(TokenType::COLON, "Expected ':'");
        auto falseExpr = parseExpression();
        return std::make_unique<TernaryExpr>(
            std::move(expr),
            std::move(trueExpr),
            std::move(falseExpr)
        );
    }

    return expr;
}
\end{lstlisting}

\subsection{Alias de Tipo (typedef)}

Permite crear nombres alternativos para tipos existentes:

\begin{lstlisting}[style=c, caption=Ejemplo de typedef]
typedef int entero;
typedef long numero_grande;
typedef float decimal;

entero x = 10;
numero_grande big = 1000000;
decimal pi = 3.14;
\end{lstlisting}

El parser mantiene un mapa \texttt{typeAliases} que asocia nombres de alias con sus tipos base.

%==============================================================================
\section{Casos de Prueba}
%==============================================================================

El compilador incluye 18 casos de prueba organizados en cuatro categorias.

\subsection{Tests de Funciones (3 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripcion} & \textbf{Salida} \\
\midrule
test\_func1.c & Funcion suma simple & 15 \\
test\_func2.c & Funcion cuadrado anidada & 49 \\
test\_func3.c & Factorial recursivo & 120 \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=c, caption=test\_func3.c - Factorial recursivo]
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

int main() {
    int result = factorial(5);
    printf("%d\n", result);  // Output: 120
    return 0;
}
\end{lstlisting}

\subsection{Tests de Implementacion Base (5 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripcion} & \textbf{Salida} \\
\midrule
test\_base1.c & Aritmetica basica & 30, 10, 200, 2 \\
test\_base2.c & Sentencias if-else & 10, 1 \\
test\_base3.c & Bucle while & 45 \\
test\_base4.c & Bucle for & 45 \\
test\_base5.c & Expresiones complejas & 11, 16, 4 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Tests de Extensiones (5 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripcion} & \textbf{Salida} \\
\midrule
test\_ext1.c & Expresiones ternarias & 10, 5 \\
test\_ext2.c & Unsigned int & 150 \\
test\_ext3.c & Long int & 3000000 \\
test\_ext4.c & Float & 6.280000 \\
test\_ext5.c & Typedef & 30, 1000000, 3.140000 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Tests de Optimizacion (5 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripcion} & \textbf{Salida} \\
\midrule
test\_opt1.c & Constant folding & 5, 50, 25 \\
test\_opt2.c & Dead code elimination & 30 \\
test\_opt3.c & Strength reduction & 16, 32 \\
test\_opt4.c & Common subexpression & 16 \\
test\_opt5.c & Loop optimization & 100 \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Ejemplo de Codigo Generado}
%==============================================================================

\subsection{Codigo Fuente}

\begin{lstlisting}[style=c, caption=Programa factorial]
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

int main() {
    int result = factorial(5);
    printf("%d\n", result);
    return 0;
}
\end{lstlisting}

\subsection{Codigo Ensamblador Generado}

\begin{lstlisting}[style=asm, caption=Codigo x86-64 generado]
.intel_syntax noprefix
.text
.global main

factorial:
    push rbp
    mov rbp, rsp
    mov rax, [rbp + 16]      ; Cargar parametro n
    push rax
    mov rax, 1
    mov rbx, rax
    pop rax
    cmp rax, rbx
    setle al
    movzx rax, al
    test rax, rax
    jz .L1                    ; Si n > 1, saltar
    mov rax, 1                ; return 1
    mov rsp, rbp
    pop rbp
    ret
.L1:
    mov rax, [rbp + 16]       ; Cargar n
    push rax
    sub rsp, 8                ; Alinear stack
    mov rax, [rbp + 16]
    push rax
    mov rax, 1
    mov rbx, rax
    pop rax
    sub rax, rbx              ; n - 1
    push rax
    call factorial            ; Llamada recursiva
    add rsp, 16
    mov rbx, rax              ; resultado en rbx
    pop rax                   ; n en rax
    imul rax, rbx             ; n * factorial(n-1)
    mov rsp, rbp
    pop rbp
    ret

main:
    push rbp
    mov rbp, rsp
    sub rsp, 16
    sub rsp, 8
    mov rax, 5
    push rax
    call factorial
    add rsp, 16
    mov [rbp - 8], rax        ; result = factorial(5)
    mov rax, [rbp - 8]
    push rax
    lea rax, [.STR0]
    push rax
    pop rdi
    pop rsi
    xor eax, eax
    call printf
    mov rax, 0
    mov rsp, rbp
    pop rbp
    ret

.data
int_fmt: .asciz "%ld\n"
.STR0: .asciz "%d\n"
\end{lstlisting}

%==============================================================================
\section{Instrucciones de Uso}
%==============================================================================

\subsection{Compilacion del Compilador}

\begin{lstlisting}[language=bash]
# Compilar el compilador
make

# Limpiar archivos generados
make clean
\end{lstlisting}

\subsection{Ejecucion}

\textbf{Linux x86-64:}
\begin{lstlisting}[language=bash]
./compiler archivo.c
gcc -no-pie output.s -o program
./program
\end{lstlisting}

\textbf{macOS (Apple Silicon):}
\begin{lstlisting}[language=bash]
./run_x86.sh archivo.c
\end{lstlisting}

\textbf{Windows (WSL2):}
\begin{lstlisting}[language=bash]
./compiler archivo.c
gcc -no-pie output.s -o program
./program
\end{lstlisting}

%==============================================================================
\section{Conclusiones}
%==============================================================================

Se logro implementar exitosamente un compilador funcional que traduce un subconjunto significativo de C a codigo ensamblador x86-64. Los principales logros incluyen:

\begin{itemize}
    \item Implementacion completa de las cuatro fases del compilador
    \item Soporte para multiples tipos de datos con promocion automatica
    \item Manejo correcto de funciones recursivas y estructuras de control
    \item Optimizaciones efectivas que reducen el codigo generado
    \item Extensiones utiles como expresiones ternarias y typedef
\end{itemize}

El proyecto demuestra la aplicacion practica de los conceptos teoricos de compiladores, incluyendo analisis lexico, parsing recursivo descendente, verificacion de tipos, generacion de codigo y optimizaciones.

\subsection{Trabajo Futuro}

Posibles mejoras para versiones futuras:

\begin{itemize}
    \item Soporte para estructuras (struct) y uniones
    \item Implementacion de punteros y memoria dinamica
    \item Optimizaciones adicionales (register allocation, peephole)
    \item Soporte para mas operadores de C
    \item Generacion de codigo para otras arquitecturas
\end{itemize}

%==============================================================================
\section{Referencias}
%==============================================================================

\begin{enumerate}
    \item Aho, A. V., Lam, M. S., Sethi, R., \& Ullman, J. D. (2006). \textit{Compilers: Principles, Techniques, and Tools} (2nd ed.). Addison-Wesley.

    \item Intel Corporation. (2021). \textit{Intel 64 and IA-32 Architectures Software Developer's Manual}.

    \item System V Application Binary Interface: AMD64 Architecture Processor Supplement.

    \item Muchnick, S. S. (1997). \textit{Advanced Compiler Design and Implementation}. Morgan Kaufmann.
\end{enumerate}

\end{document}
