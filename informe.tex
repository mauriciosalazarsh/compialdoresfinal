\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{float}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc,fit,backgrounds}

\geometry{margin=2.5cm}

\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    tabsize=4
}

\lstdefinestyle{cpp}{
    language=C++,
    morekeywords={nullptr, override, final, noexcept, constexpr, auto}
}

\lstdefinestyle{asm}{
    language=[x86masm]Assembler,
    morekeywords={push, pop, mov, add, sub, imul, idiv, cmp, jmp, jz, jnz, jl, jle, jg, jge, call, ret, lea, xor, test, sete, setne, setl, setle, setg, setge, movzx, cqo, cdqe, rbp, rsp, rax, rbx, rcx, rdx, rdi, rsi, xmm0, xmm1}
}

\lstdefinestyle{c}{
    language=C,
    morekeywords={int, long, float, unsigned, void, return, if, else, while, for, typedef}
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{CS3402 - Compiladores}
\fancyhead[R]{UTEC}
\fancyfoot[C]{\thepage}

\title{
    \vspace{-2cm}
    \Large\textbf{Universidad de Ingeniería y Tecnología}\\[0.5cm]
    \large Facultad de Computación\\[1cm]
    \Huge\textbf{Compilador de C a x86-64}\\[0.5cm]
    \Large Proyecto Final\\[1cm]
    \large CS3402 - Compiladores
}

\author{
    Salazar Hillenbrand, Mauricio\\
    Alvarado Vargas, Fabian Martín\
}

\date{Noviembre 2025}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Introducción}

El presente documento describe el diseño e implementación de un compilador que traduce un subconjunto del lenguaje C a código ensamblador x86-64. El compilador fue desarrollado en C++ siguiendo una arquitectura modular que comprende las fases clásicas de compilación: análisis léxico, análisis sintáctico, análisis semántico y generación de código.

\subsection{Objetivos}

\begin{itemize}
    \item Implementar un compilador funcional para un subconjunto de C
    \item Generar código ensamblador x86-64 ejecutable
    \item Aplicar técnicas de optimización en tiempo de compilación
    \item Soportar tipos de datos numéricos adicionales (float, long, unsigned int)
    \item Implementar extensiones del lenguaje (expresiones ternarias, typedef)
\end{itemize}

\subsection{Alcance}

El compilador soporta las siguientes características del lenguaje C:

\begin{itemize}
    \item Declaración de variables con tipos int, long, unsigned int y float
    \item Operaciones aritméticas, relacionales y lógicas
    \item Estructuras de control: if-else, while, for
    \item Definición y llamada de funciones, incluyendo recursión
    \item Expresiones ternarias (operador ?:)
    \item Alias de tipos mediante typedef
\end{itemize}

\section{Repositorio del Proyecto}

El código fuente completo, casos de prueba y scripts adicionales se encuentran disponibles en el repositorio oficial del proyecto:

\begin{itemize}
    \item \textbf{GitHub:} \url{https://github.com/mauriciosalazarsh/compialdoresfinal.git}
\end{itemize}


\section{Arquitectura del Compilador}

El compilador sigue una arquitectura de pipeline con cuatro fases principales, cada una implementada como un módulo independiente.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.5cm,
    block/.style={rectangle, draw=black, line width=1pt, fill=blue!15, text width=2.2cm, text centered, minimum height=1cm, font=\small\bfseries, rounded corners=3pt},
    io/.style={rectangle, draw=black, line width=1pt, fill=green!15, text width=2.2cm, text centered, minimum height=1cm, font=\small\bfseries, rounded corners=3pt},
    myarrow/.style={-stealth, thick, line width=1pt}
]
    \node[io] (source) {Código Fuente (.c)};
    \node[block, right=of source] (scanner) {Scanner};
    \node[block, right=of scanner] (parser) {Parser};
    \node[block, right=of parser] (semantic) {Semantic};
    \node[block, right=of semantic] (codegen) {CodeGen};
    \node[io, right=of codegen] (output) {Código x86-64 (.s)};

    \draw[myarrow] (source) -- (scanner);
    \draw[myarrow] (scanner) -- (parser);
    \draw[myarrow] (parser) -- (semantic);
    \draw[myarrow] (semantic) -- (codegen);
    \draw[myarrow] (codegen) -- (output);
\end{tikzpicture}
\caption{Pipeline del compilador}
\end{figure}

\subsection{Estructura de Archivos}

\begin{lstlisting}[caption=Estructura del proyecto]
Final/
|-- src/
|   |-- main.cpp          # Punto de entrada
|   |-- scanner.cpp       # Analizador léxico
|   |-- parser.cpp        # Analizador sintáctico
|   |-- semantic.cpp      # Analizador semántico
|   |-- codegen.cpp       # Generador de código
|   |-- ast.cpp           # Nodos del AST
|   |-- symboltable.cpp   # Tabla de símbolos
|-- include/
|   |-- scanner.h
|   |-- parser.h
|   |-- ast.h
|   |-- visitor.h
|   |-- semantic.h
|   |-- codegen.h
|   |-- symboltable.h
|-- tests/                # 18 casos de prueba
|-- visualizer/           # Bonus: visualizador web
\end{lstlisting}

\section{Análisis Léxico (Scanner)}

El analizador léxico convierte el código fuente en una secuencia de tokens. Está implementado en la clase \texttt{Scanner} utilizando un enfoque de análisis carácter por carácter.

\subsection{Clase Scanner}

\begin{lstlisting}[style=cpp, caption=Estructura principal del Scanner]
class Scanner {
private:
    std::string input;
    size_t pos;
    int line, column;
    char current;

    void advance();
    char peek(int offset = 1);
    void skipWhitespace();
    void skipComment();
    void skipPreprocessor();
    Token scanNumber();
    Token scanIdentifier();
    Token scanString();

public:
    Scanner(const std::string& src);
    Token nextToken();
    std::vector<Token> tokenize();
};
\end{lstlisting}

\subsection{Tipos de Tokens}

El scanner reconoce los siguientes tipos de tokens:

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Categoria} & \textbf{Tokens} & \textbf{Ejemplos} \\
\midrule
Palabras clave & int, long, float, unsigned, void & \texttt{int x;} \\
               & if, else, while, for, return & \texttt{if (x > 0)} \\
               & typedef & \texttt{typedef int entero;} \\
Literales & NUM, FLOAT\_LIT, STRING\_LIT & \texttt{42}, \texttt{3.14}, \texttt{"hola"} \\
Identificadores & ID & \texttt{variable}, \texttt{función} \\
Operadores & +, -, *, /, \%, ==, !=, <, >, <=, >= & \texttt{a + b} \\
Delimitadores & (, ), \{, \}, [, ], ;, , & \texttt{func(a, b)} \\
\bottomrule
\end{tabular}
\caption{Tipos de tokens reconocidos}
\end{table}

\subsection{Manejo de Números}

El scanner detecta automáticamente el tipo de literal numérico:

\begin{lstlisting}[style=cpp, caption=Escaneo de literales numéricos]
Token Scanner::scanNumber() {
    std::string num;
    bool isFloat = false;

    while (std::isdigit(current)) {
        num += current;
        advance();
    }

    // Detectar punto decimal
    if (current == '.' && std::isdigit(peek())) {
        isFloat = true;
        num += current;
        advance();
        while (std::isdigit(current)) {
            num += current;
            advance();
        }
    }

    return Token(isFloat ? TokenType::FLOAT_LIT
                        : TokenType::NUM, num);
}
\end{lstlisting}

\section{Análisis Sintáctico (Parser)}

El analizador sintáctico implementa un parser recursivo descendente que construye un Árbol de Sintaxis Abstracta (AST).

\subsection{Clase Parser}

\begin{lstlisting}[style=cpp, caption=Estructura del Parser]
class Parser {
private:
    std::vector<Token> tokens;
    size_t current;
    std::map<std::string, DataType> typeAliases;

    Token peek(int offset = 0);
    Token advance();
    bool match(TokenType type);
    bool check(TokenType type);
    void expect(TokenType type, const std::string& msg);

    DataType parseType();
    void parseTypedef();

    std::unique_ptr<Expr> parseExpression();
    std::unique_ptr<Expr> parseTernary();
    std::unique_ptr<Expr> parseLogicalOr();

public:
    std::unique_ptr<Program> parse();
};
\end{lstlisting}

\subsection{Jerarquía del AST}

El AST utiliza el patrón Visitor para permitir múltiples recorridos:

\begin{figure}[H]
\centering
% \resizebox{\textwidth}{!}{  <-- Si aun asi queda grande, descomenta esta linea y la llave del final
\begin{tikzpicture}[
    base/.style={rectangle, draw=black, line width=0.8pt, minimum height=0.6cm, text centered, font=\footnotesize\ttfamily, rounded corners=2pt},
    root/.style={base, fill=red!20, text width=1.8cm},
    abst/.style={base, fill=orange!20, text width=1.3cm},
    leaf/.style={base, fill=blue!15, text width=2.1cm}, % Mantenemos el ancho para el texto
    myarrow/.style={-stealth, thick, rounded corners=2pt} 
]
    % --- NODOS ---
    
    % Nivel 0: Raíz
    \node[root] (node) at (0, 0) {ASTNode};

    % Nivel 1: Clases abstractas (ACERCADAS: de -5/5 pasamos a -4/4)
    \node[abst] (expr) at (-4.0, -1.2) {Expr};
    \node[abst] (stmt) at (4.0, -1.2) {Stmt};

    % --- LADO IZQUIERDO (Expr) ---
    % Nivel 2 Fila Superior: (-6.4, -4.0, -1.6)
    % Se han comprimido las distancias horizontales
    \node[leaf] (binary) at (-6.4, -2.6) {BinaryExpr};
    \node[leaf] (unary) at (-4.0, -2.6) {UnaryExpr};
    \node[leaf] (ternary) at (-1.6, -2.6) {TernaryExpr}; 
    
    % Nivel 2 Fila Inferior: Intercalados
    \node[leaf] (literal) at (-5.2, -4.2) {LiteralExpr};
    \node[leaf] (call) at (-2.8, -4.2) {CallExpr};


    % --- LADO DERECHO (Stmt) ---
    % Nivel 2 Fila Superior: (1.6, 4.0, 6.4)
    \node[leaf] (vardecl) at (1.6, -2.6) {VarDeclStmt}; 
    \node[leaf] (ifstmt) at (4.0, -2.6) {IfStmt};
    \node[leaf] (whilestmt) at (6.4, -2.6) {WhileStmt};
    
    % Nivel 2 Fila Inferior: Intercalados
    \node[leaf] (forstmt) at (2.8, -4.2) {ForStmt};
    \node[leaf] (block) at (5.2, -4.2) {BlockStmt};


    % --- CONEXIONES ---

    % 1. Herencia principal
    \draw[myarrow] (expr) -- (node);
    \draw[myarrow] (stmt) -- (node);

    % 2. Hijos de EXPR
    \draw[myarrow] (binary.north) -- ++(0, 0.6) -| (expr.south);
    \draw[myarrow] (unary.north)  -- ++(0, 0.6) -| (expr.south);
    \draw[myarrow] (ternary.north)-- ++(0, 0.6) -| (expr.south);

    \draw[myarrow] (literal.north) -- ++(0, 2.2) -| (expr.south);
    \draw[myarrow] (call.north)    -- ++(0, 2.2) -| (expr.south);

    % 3. Hijos de STMT
    \draw[myarrow] (vardecl.north)  -- ++(0, 0.6) -| (stmt.south);
    \draw[myarrow] (ifstmt.north)   -- ++(0, 0.6) -| (stmt.south);
    \draw[myarrow] (whilestmt.north)-- ++(0, 0.6) -| (stmt.south);

    \draw[myarrow] (forstmt.north) -- ++(0, 2.2) -| (stmt.south);
    \draw[myarrow] (block.north)   -- ++(0, 2.2) -| (stmt.south);

\end{tikzpicture}
% } % Llave de cierre del resizebox
\caption{Jerarquía de clases del AST}
\end{figure}


\subsection{Precedencia de Operadores}

La precedencia se implementa mediante funciones de parsing separadas:

\begin{table}[H]
\centering
\begin{tabular}{clc}
\toprule
\textbf{Nivel} & \textbf{Operadores} & \textbf{Función} \\
\midrule
1 (menor) & ?: (ternario) & \texttt{parseTernary()} \\
2 & || & \texttt{parseLogicalOr()} \\
3 & \&\& & \texttt{parseLogicalAnd()} \\
4 & ==, != & \texttt{parseEquality()} \\
5 & <, >, <=, >= & \texttt{parseRelational()} \\
6 & +, - & \texttt{parseAdditive()} \\
7 & *, /, \% & \texttt{parseMultiplicative()} \\
8 (mayor) & -, ! (unarios) & \texttt{parseUnary()} \\
\bottomrule
\end{tabular}
\caption{Niveles de precedencia}
\end{table}

\subsection{Soporte para Typedef}

El parser mantiene un mapa de alias de tipos:

\begin{lstlisting}[style=cpp, caption=Implementación de typedef]
void Parser::parseTypedef() {
    expect(TokenType::TYPEDEF, "Expected 'typedef'");
    DataType baseType = parseType();

    std::string aliasName = peek().lexeme;
    expect(TokenType::ID, "Expected type alias name");
    expect(TokenType::SEMICOLON, "Expected ';'");

    // Almacenar el alias
    typeAliases[aliasName] = baseType;
}

bool Parser::isTypeToken() {
    if (check(TokenType::INT) || check(TokenType::LONG) ||
        check(TokenType::FLOAT) || check(TokenType::UNSIGNED)) {
        return true;
    }
    // Verificar si es un alias de typedef
    if (check(TokenType::ID)) {
        return typeAliases.find(peek().lexeme)
               != typeAliases.end();
    }
    return false;
}
\end{lstlisting}

\section{Análisis Semántico}

El analizador semántico verifica la corrección del programa mediante el patrón Visitor.

\subsection{Clase SemanticAnalyzer}

\begin{lstlisting}[style=cpp, caption=Estructura del analizador semántico]
class SemanticAnalyzer : public Visitor {
private:
    SymbolTable& symbolTable;
    DataType currentFunctionReturnType;
    bool hasErrors;
    std::string errors;

    bool areTypesCompatible(DataType expected,
                           DataType actual);
    DataType getCommonType(DataType t1, DataType t2);
    void error(const std::string& message);

public:
    void visit(BinaryExpr* node) override;
    void visit(TernaryExpr* node) override;
    void visit(CallExpr* node) override;
    void visit(VarDeclStmt* node) override;
    void visit(FunctionDecl* node) override;
};
\end{lstlisting}

\subsection{Sistema de Tipos}

El compilador soporta cuatro tipos numéricos con promoción automática:

\begin{lstlisting}[style=cpp, caption=Promoción de tipos]
DataType SemanticAnalyzer::getCommonType(DataType t1,
                                         DataType t2) {
    if (t1 == t2) return t1;

    // Float domina sobre todos
    if (t1 == DataType::FLOAT || t2 == DataType::FLOAT)
        return DataType::FLOAT;

    // Long domina sobre Int
    if (t1 == DataType::LONG || t2 == DataType::LONG)
        return DataType::LONG;

    // UINT con INT -> LONG (para evitar overflow)
    if ((t1 == DataType::UINT && t2 == DataType::INT) ||
        (t1 == DataType::INT && t2 == DataType::UINT))
        return DataType::LONG;

    return t1;
}
\end{lstlisting}

\subsection{Tabla de Símbolos}

La tabla de símbolos maneja ámbitos anidados mediante una pila de scopes:

\begin{lstlisting}[style=cpp, caption=Estructura de la tabla de símbolos]
struct Symbol {
    std::string name;
    DataType type;
    bool isMutable;
    bool isParameter;
    int offset;  // Offset en el stack frame
    std::vector<int> arrayDimensions;
};

class SymbolTable {
private:
    std::vector<std::map<std::string, Symbol>> scopes;
    std::map<std::string, FunctionSymbol> functions;
    int currentOffset;

public:
    void enterScope();
    void exitScope();
    bool declareVariable(const std::string& name,
                        const Symbol& sym);
    Symbol* lookup(const std::string& name);
    int allocateStackSpace(int size);
};
\end{lstlisting}

\section{Generación de Código}

El generador de código produce ensamblador x86-64 en sintaxis Intel, siguiendo la convención de llamadas System V ABI.

\subsection{Clase CodeGenerator}

\begin{lstlisting}[style=cpp, caption=Estructura del generador de código]
class CodeGenerator : public Visitor {
private:
    SymbolTable& symbolTable;
    std::stringstream code;
    std::stringstream dataSection;
    int labelCounter;
    int stringCounter;
    bool enableConstantFolding;
    bool enableDeadCodeElimination;

    std::string newLabel();
    void emit(const std::string& instruction);
    void emitLabel(const std::string& label);
    void generatePrologue(const std::string& func,
                         int stackSize);
    void generateEpilogue();

public:
    void visit(BinaryExpr* node) override;
    void visit(CallExpr* node) override;
    void visit(IfStmt* node) override;

    std::string getCode() const;
};
\end{lstlisting}

\subsection{Convención de Llamadas (System V ABI)}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Registro} & \textbf{Uso} \\
\midrule
rax & Valor de retorno, acumulador \\
rbx & Registro temporal (callee-saved) \\
rdi, rsi, rdx, rcx, r8, r9 & Argumentos 1-6 \\
rbp & Base pointer (marco de pila) \\
rsp & Stack pointer \\
xmm0-xmm1 & Operaciones de punto flotante \\
\bottomrule
\end{tabular}
\caption{Uso de registros x86-64}
\end{table}

\subsection{Estructura del Stack Frame}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    cell/.style={rectangle, draw=black, line width=0.8pt, minimum width=5cm, minimum height=0.8cm, font=\small},
    high/.style={cell, fill=red!10},
    mid/.style={cell, fill=yellow!15},
    low/.style={cell, fill=blue!10},
    myarrow/.style={-stealth, thick, line width=1pt}
]
    \node[high] (arg) at (0, 0) {Argumentos (arg3, arg2, arg1)};
    \node[high] (ret) at (0, -0.8) {Direccion de retorno};
    \node[mid] (rbpnode) at (0, -1.6) {RBP anterior (saved rbp)};
    \node[low] (local) at (0, -2.4) {Variables locales};
    \node[low] (temp) at (0, -3.2) {Espacio temporal};

    \draw[myarrow] (3, -1.6) -- (2.6, -1.6);
    \node[right] at (3, -1.6) {\texttt{rbp}};

    \draw[myarrow] (3, -3.2) -- (2.6, -3.2);
    \node[right] at (3, -3.2) {\texttt{rsp}};

    \node[left, font=\footnotesize\ttfamily] at (-2.8, 0) {[rbp+24]};
    \node[left, font=\footnotesize\ttfamily] at (-2.8, -0.8) {[rbp+8]};
    \node[left, font=\footnotesize\ttfamily] at (-2.8, -1.6) {[rbp]};
    \node[left, font=\footnotesize\ttfamily] at (-2.8, -2.4) {[rbp-8]};
    \node[left, font=\footnotesize\ttfamily] at (-2.8, -3.2) {[rbp-16]};

    \node[above] at (0, 0.5) {\textbf{Direcciones altas}};
    \node[below] at (0, -3.8) {\textbf{Direcciones bajas}};
\end{tikzpicture}
\caption{Estructura del stack frame en x86-64}
\end{figure}

\subsection{Generación de Prólogo y Epílogo}

\begin{lstlisting}[style=cpp, caption=Generación del prólogo de función]
void CodeGenerator::generatePrologue(const std::string& func,
                                     int stackSize) {
    emitLabel(func);
    emit("push rbp");
    emit("mov rbp, rsp");

    // Alinear stack a 16 bytes (requerido por ABI)
    int alignedSize = ((stackSize + 15) & ~15);
    if (alignedSize > 0) {
        emit("sub rsp, " + std::to_string(alignedSize));
    }
}

void CodeGenerator::generateEpilogue() {
    emit("mov rsp, rbp");
    emit("pop rbp");
    emit("ret");
}
\end{lstlisting}

\subsection{Generación de Expresiones Binarias}

\begin{lstlisting}[style=cpp, caption=Generación de operaciones aritméticas]
void CodeGenerator::visit(BinaryExpr* node) {
    // Evaluar operandos
    node->left->accept(this);
    emit("push rax");  // Guardar operando izquierdo

    node->right->accept(this);
    emit("mov rbx, rax");  // Operando derecho en rbx
    emit("pop rax");        // Operando izquierdo en rax

    // Generar operación
    if (node->op == "+") {
        emit("add rax, rbx");
    } else if (node->op == "-") {
        emit("sub rax, rbx");
    } else if (node->op == "*") {
        emit("imul rax, rbx");
    } else if (node->op == "/") {
        emit("cqo");        // Sign extend rax to rdx:rax
        emit("idiv rbx");   // Resultado en rax
    } else if (node->op == "%") {
        emit("cqo");
        emit("idiv rbx");
        emit("mov rax, rdx"); // Resto en rdx
    }
}
\end{lstlisting}

\subsection{Generación de Expresiones Ternarias}

\begin{lstlisting}[style=cpp, caption=Generación del operador ternario]
void CodeGenerator::visit(TernaryExpr* node) {
    std::string falseLabel = newLabel();
    std::string endLabel = newLabel();

    // Evaluar condición
    node->condition->accept(this);
    emit("test rax, rax");
    emit("jz " + falseLabel);

    // Rama verdadera
    node->trueExpr->accept(this);
    emit("jmp " + endLabel);

    // Rama falsa
    emitLabel(falseLabel);
    node->falseExpr->accept(this);

    emitLabel(endLabel);
}
\end{lstlisting}

\subsection{Generación de Estructuras de Control}

\begin{lstlisting}[style=cpp, caption=Generación de if-else]
void CodeGenerator::visit(IfStmt* node) {
    std::string elseLabel = newLabel();
    std::string endLabel = newLabel();

    node->condition->accept(this);
    emit("test rax, rax");

    if (node->elseBranch) {
        emit("jz " + elseLabel);
        node->thenBranch->accept(this);
        emit("jmp " + endLabel);
        emitLabel(elseLabel);
        node->elseBranch->accept(this);
        emitLabel(endLabel);
    } else {
        emit("jz " + endLabel);
        node->thenBranch->accept(this);
        emitLabel(endLabel);
    }
}
\end{lstlisting}

\begin{lstlisting}[style=cpp, caption=Generación de bucle while]
void CodeGenerator::visit(WhileStmt* node) {
    std::string startLabel = newLabel();
    std::string endLabel = newLabel();

    emitLabel(startLabel);
    node->condition->accept(this);
    emit("test rax, rax");
    emit("jz " + endLabel);

    node->body->accept(this);
    emit("jmp " + startLabel);

    emitLabel(endLabel);
}
\end{lstlisting}

\section{Optimizaciones}

El compilador implementa dos optimizaciones principales aplicadas durante la generación de código.

\subsection{Constant Folding (Plegado de Constantes)}

Esta optimización evalúa expresiones constantes en tiempo de compilación:

\begin{lstlisting}[style=cpp, caption=Implementación de constant folding]
void CodeGenerator::visit(BinaryExpr* node) {
    if (enableConstantFolding) {
        auto leftLit = dynamic_cast<LiteralExpr*>(
                           node->left.get());
        auto rightLit = dynamic_cast<LiteralExpr*>(
                            node->right.get());

        if (leftLit && rightLit &&
            node->exprType != DataType::FLOAT) {
            long long leftVal = std::stoll(leftLit->value);
            long long rightVal = std::stoll(rightLit->value);
            long long result = 0;

            if (node->op == "+")
                result = leftVal + rightVal;
            else if (node->op == "-")
                result = leftVal - rightVal;
            else if (node->op == "*")
                result = leftVal * rightVal;
            else if (node->op == "/" && rightVal != 0)
                result = leftVal / rightVal;

            // Emitir resultado constante directamente
            emit("mov rax, " + std::to_string(result));
            return;
        }
    }
}
\end{lstlisting}

\textbf{Ejemplo:}
\begin{lstlisting}[style=c]
int x = 5 + 10 * 2;  // Se evalúa como 25 en compilación
\end{lstlisting}

Código generado optimizado:
\begin{lstlisting}[style=asm]
mov rax, 25          ; En lugar de múltiples operaciones
\end{lstlisting}

\subsection{Dead Code Elimination (Eliminación de Código Muerto)}

El compilador detecta y omite código que nunca se ejecutará:

\begin{lstlisting}[style=cpp, caption=Eliminación de código muerto en if]
void CodeGenerator::visit(IfStmt* node) {
    // Verificar si la condición es constante
    if (auto lit = dynamic_cast<LiteralExpr*>(
                       node->condition.get())) {
        if (lit->value == "0") {
            // Condición siempre falsa: solo generar else
            if (node->elseBranch) {
                node->elseBranch->accept(this);
            }
            return;  // Omitir rama then
        } else {
            // Condición siempre verdadera: solo generar then
            node->thenBranch->accept(this);
            return;  // Omitir rama else
        }
    }
}
\end{lstlisting}

\textbf{Ejemplo:}
\begin{lstlisting}[style=c]
if (0) {
    z = 100;  // Este código nunca se ejecuta
}
\end{lstlisting}

El compilador no genera código para el bloque interno.

\section{Extensiones Implementadas}

\subsection{Expresiones Ternarias}

El operador ternario \texttt{?:} permite expresiones condicionales en línea:

\begin{lstlisting}[style=c, caption=Ejemplo de expresión ternaria]
int max = (x > y) ? x : y;
int result = (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
\end{lstlisting}

La implementación en el parser:

\begin{lstlisting}[style=cpp]
std::unique_ptr<Expr> Parser::parseTernary() {
    auto expr = parseLogicalOr();

    if (match(TokenType::QUESTION)) {
        auto trueExpr = parseExpression();
        expect(TokenType::COLON, "Expected ':'");
        auto falseExpr = parseExpression();
        return std::make_unique<TernaryExpr>(
            std::move(expr),
            std::move(trueExpr),
            std::move(falseExpr)
        );
    }

    return expr;
}
\end{lstlisting}

\subsection{Alias de Tipo (typedef)}

Permite crear nombres alternativos para tipos existentes:

\begin{lstlisting}[style=c, caption=Ejemplo de typedef]
typedef int entero;
typedef long numero_grande;
typedef float decimal;

entero x = 10;
numero_grande big = 1000000;
decimal pi = 3.14;
\end{lstlisting}

El parser mantiene un mapa \texttt{typeAliases} que asocia nombres de alias con sus tipos base.

\section{Casos de Prueba}

El compilador incluye 18 casos de prueba organizados en cuatro categorías.

\subsection{Tests de Funciones (3 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripción} & \textbf{Salida} \\
\midrule
test\_func1.c & Función suma simple & 15 \\
test\_func2.c & Función cuadrado anidada & 49 \\
test\_func3.c & Factorial recursivo & 120 \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=c, caption=test\_func3.c - Factorial recursivo]
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

int main() {
    int result = factorial(5);
    printf("%d\n", result);  // Output: 120
    return 0;
}
\end{lstlisting}

\subsection{Tests de Implementación Base (5 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripción} & \textbf{Salida} \\
\midrule
test\_base1.c & Aritmética básica & 30, 10, 200, 2 \\
test\_base2.c & Sentencias if-else & 10, 1 \\
test\_base3.c & Bucle while & 45 \\
test\_base4.c & Bucle for & 45 \\
test\_base5.c & Expresiones complejas & 11, 16, 4 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Tests de Extensiones (5 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripción} & \textbf{Salida} \\
\midrule
test\_ext1.c & Expresiones ternarias & 10, 5 \\
test\_ext2.c & Unsigned int & 150 \\
test\_ext3.c & Long int & 3000000 \\
test\_ext4.c & Float & 6.280000 \\
test\_ext5.c & Typedef & 30, 1000000, 3.140000 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Tests de Optimización (5 casos)}

\begin{table}[H]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Test} & \textbf{Descripción} & \textbf{Salida} \\
\midrule
test\_opt1.c & Constant folding & 5, 50, 25 \\
test\_opt2.c & Dead code elimination & 30 \\
test\_opt3.c & Strength reduction & 16, 32 \\
test\_opt4.c & Common subexpression & 16 \\
test\_opt5.c & Loop optimization & 100 \\
\bottomrule
\end{tabular}
\end{table}

\section{Ejemplo de Código Generado}

\subsection{Código Fuente}

\begin{lstlisting}[style=c, caption=Programa factorial]
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

int main() {
    int result = factorial(5);
    printf("%d\n", result);
    return 0;
}
\end{lstlisting}

\subsection{Código Ensamblador Generado}

\begin{lstlisting}[style=asm, caption=Código x86-64 generado]
.intel_syntax noprefix
.text
.global main

factorial:
    push rbp
    mov rbp, rsp
    mov rax, [rbp + 16]      ; Cargar parámetro n
    push rax
    mov rax, 1
    mov rbx, rax
    pop rax
    cmp rax, rbx
    setle al
    movzx rax, al
    test rax, rax
    jz .L1                    ; Si n > 1, saltar
    mov rax, 1                ; return 1
    mov rsp, rbp
    pop rbp
    ret
.L1:
    mov rax, [rbp + 16]       ; Cargar n
    push rax
    sub rsp, 8                ; Alinear stack
    mov rax, [rbp + 16]
    push rax
    mov rax, 1
    mov rbx, rax
    pop rax
    sub rax, rbx              ; n - 1
    push rax
    call factorial            ; Llamada recursiva
    add rsp, 16
    mov rbx, rax              ; resultado en rbx
    pop rax                   ; n en rax
    imul rax, rbx             ; n * factorial(n-1)
    mov rsp, rbp
    pop rbp
    ret

main:
    push rbp
    mov rbp, rsp
    sub rsp, 16
    sub rsp, 8
    mov rax, 5
    push rax
    call factorial
    add rsp, 16
    mov [rbp - 8], rax        ; result = factorial(5)
    mov rax, [rbp - 8]
    push rax
    lea rax, [.STR0]
    push rax
    pop rdi
    pop rsi
    xor eax, eax
    call printf
    mov rax, 0
    mov rsp, rbp
    pop rbp
    ret

.data
int_fmt: .asciz "%ld\n"
.STR0: .asciz "%d\n"
\end{lstlisting}

\section{Instrucciones de Uso}

\subsection{Compilación del Compilador}

\begin{lstlisting}[language=bash]
# Compilar el compilador
make

# Limpiar archivos generados
make clean
\end{lstlisting}

\subsection{Ejecución}

\textbf{Linux x86-64:}
\begin{lstlisting}[language=bash]
./compiler archivo.c
gcc -no-pie output.s -o program
./program
\end{lstlisting}

\textbf{macOS (Apple Silicon):}
\begin{lstlisting}[language=bash]
./run_x86.sh archivo.c
\end{lstlisting}

\textbf{Windows (WSL2):}
\begin{lstlisting}[language=bash]
./compiler archivo.c
gcc -no-pie output.s -o program
./program
\end{lstlisting}

\section{Conclusiones}

Se logró implementar exitosamente un compilador funcional que traduce un subconjunto significativo de C a código ensamblador x86-64. Los principales logros incluyen:

\begin{itemize}
    \item Implementación completa de las cuatro fases del compilador
    \item Soporte para múltiples tipos de datos con promoción automática
    \item Manejo correcto de funciones recursivas y estructuras de control
    \item Optimizaciones efectivas que reducen el código generado
    \item Extensiones útiles como expresiones ternarias y typedef
\end{itemize}

El proyecto demuestra la aplicación práctica de los conceptos teóricos de compiladores, incluyendo análisis léxico, parsing recursivo descendente, verificación de tipos, generación de código y optimizaciones.

\subsection{Trabajo Futuro}

Posibles mejoras para versiones futuras:

\begin{itemize}
    \item Soporte para estructuras (struct) y uniones
    \item Implementación de punteros y memoria dinámica
    \item Optimizaciones adicionales (register allocation, peephole)
    \item Soporte para más operadores de C
    \item Generación de código para otras arquitecturas
\end{itemize}

\section{Referencias}

\begin{enumerate}
    \item Aho, A. V., Lam, M. S., Sethi, R., \& Ullman, J. D. (2006). \textit{Compilers: Principles, Techniques, and Tools} (2nd ed.). Addison-Wesley.

    \item Intel Corporation. (2021). \textit{Intel 64 and IA-32 Architectures Software Developer's Manual}.

    \item System V Application Binary Interface: AMD64 Architecture Processor Supplement.

    \item Muchnick, S. S. (1997). \textit{Advanced Compiler Design and Implementation}. Morgan Kaufmann.
\end{enumerate}

\end{document}
